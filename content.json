{"meta":{"title":"飘叶音","subtitle":"piaoyeyin","description":"Your Eyes Can See the World Without Me.","author":"Chill Yu","url":"http://piaoyeyin.top"},"pages":[{"title":"categories","date":"2017-09-07T17:17:40.000Z","updated":"2017-09-07T17:17:40.000Z","comments":true,"path":"categories/index.html","permalink":"http://piaoyeyin.top/categories/index.html","excerpt":"","text":""},{"title":"好好说再见","date":"2017-09-07T15:53:53.000Z","updated":"2017-09-22T00:11:16.000Z","comments":true,"path":"about/index.html","permalink":"http://piaoyeyin.top/about/index.html","excerpt":"","text":"我爱过你笑的脸庞 我爱过你心的善良这些年有你的时光 把我的孤独都照亮我记得你说过的话 (时间留不住一句话)我记得曾为你疯狂 (何时过了年少轻狂)当情太深而缘太浅 (当你离开我的世界)至少要好好说再见 (要怎么好好说再见)一直以为真爱能直到永远彼此相爱的每一天都是永远一直以为我们有同一个明天你曾是我的世界 不完整的世界 如果花谢了会再开 如果错了的还能改这些年累积的关怀 怎能说不在就不在感情不该一直受伤(为何爱总是带着伤)我不愿让你再失望(有期望才会有失望)当幸福碎成一片片(一颗心碎成一片片)至少要好好说再见(要怎么好好说再见)一直以为真爱能直到永远彼此相爱的每一天都是永远一直以为我们有同一个明天你曾是我的世界 不完整的世界相信你会过得更好 我还不想把你忘掉别丢弃你无邪的笑 再见面还可以拥抱 我记得你说过的话(时间留不住一句话)我记得曾为你疯狂(何时过了年少轻狂)当爱情不再像从前(你永远是我的从前)原谅我沉默的再见"},{"title":"tags","date":"2017-09-07T17:17:51.000Z","updated":"2017-09-07T17:17:51.000Z","comments":true,"path":"tags/index.html","permalink":"http://piaoyeyin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python单例模式","slug":"python-singleton","date":"2017-11-27T08:22:21.000Z","updated":"2017-11-27T08:25:43.081Z","comments":true,"path":"2017/11/27/python-singleton/","link":"","permalink":"http://piaoyeyin.top/2017/11/27/python-singleton/","excerpt":"","text":"单例模式确保类有且只有一个特定类型的对象，并提供一个全局的访问点。控制共享资源的并行访问。 常用于： 日志记录，数据库操作，打印机后台处理操作等。这类程序的特点是，运行过程中只能生成一个实例，以避免对同一资源产生相互冲突的请求。 UML图： Singleton |———————-|-instance: Singleton |-Singleton() +instance(): Singleton| 实现单例模式的简单方法是：使构造函数私有化，并创建一个静态方法来完成对象的初始化。但python无法创建私有的构造函数，因此实现方法需要变通。 经典单例实现：12345class Singleton(object): def __new__(cls): if not hasattr(cls, 'instance'): # 创建对象之前，先检查对象是否存在 cls.instance = super(Singleton, cls).__new__(cls) return cls.instance ###讲解： __new__方法和__init__方法： __init__方法：创建实例后会立即执行对象的__init__方法。该方法接受一个位置参数self，然后可以接受任意数量的必要或可选的位置参数，以及任意数量的关键字参数。类调用的初始化参数会被传递给__init__方法。需要注意：__init__方法并没有创建新的对象，该方法目的在于为创建后的对象提供初始化的数据。因此它也不返回任何值，否则会导致TypeError错误。 12345678910&gt; class Dice(object):&gt; def __init__(self, sides=6):&gt; self._sides = sides&gt; def roll(self):&gt; return random.randint(1, self._sides)&gt; &gt; die = Dice() # random int in (1,6)&gt; die = Dice(sides=20)&gt; print(die.roll()) # random int in (1,20)&gt; __new__方法：实际在__init__方法之前执行，它才是负责创建并返回实例的方法。__new__方法永远是静态的，也无须显式装饰。第一重要参数是创建实例的类(习惯命名为cls)。大多数情况下，__new__方法其他参数会被完整的复制到__init__方法中。实际应用中，大多数类无须定义该方法，内置实现已经足够。但一个类需要定义该方法时，几乎都需要首先在实现本类逻辑之前引用负累的实现。需要注意：如果__new__方法返回的不是当前类的实例，就不会调用__init__方法。 123456&gt; class MyClass(object):&gt; def __new__(cls, [...]):&gt; instance = super(MyClass, cls).__new__(cls, [...])&gt; # do work on instance&gt; return instance&gt; hasattr()方法，用于判断对象是否包含对应的属性。hasattr(object, name) 123456&gt; class Coordinate:&gt; x = 10&gt; &gt; point1 = Coordinate() &gt; print(hasattr(point1, 'x')) # True&gt; print(hasattr(point1, 'y')) # False 懒汉式实例化确保在实际需要的时候才创建对象，节约资源。 1234567891011121314151617181920class Singleton: __instance = None def __init__(self): if not Singleton.__instance: print(\"__init__ method called..\") else: print(\"instance already created: \", Singleton.getInstance()) @classmethod def getInstance(cls): if not cls.__instance: cls.__instance = Singleton() return cls.__instanceif __name__ == '__main__': s = Singleton() # 初始化类调，调用init方法，但是新对象并没有创建。 print(\"object created:\", Singleton.getInstance()) # 实际的对象创建发生在调用Singleton.getInstance()的时候 s1 = Singleton() # 对象已经被创建。 模块级别的单例模式默认情况下，所有模块都是单例。由python的导入行为决定的。模块导入的时候，就会被初始化。当模块再次导入的时候，它不会再次初始化，它会返回同一个对象。 Monostate（单态）单例模式得到不同的对象，但对象的状态却是相同的。 123456789101112131415161718192021222324252627282930313233343536373839class Borg: __shared_state = &#123;\"x\": 1&#125; def __init__(self): self.y = 2 self.__dict__ = self.__shared_state passclass Borg1(object): __shared_state = &#123;&#125; def __new__(cls, *args, **kwargs): obj = super(Borg1, cls).__new__(cls) obj.__dict__ = cls.__shared_state return objdef init_method(): b = Borg() b1 = Borg() print(b, b1) # &lt;__main__.Borg object at 0x100dcc390&gt; &lt;__main__.Borg object at 0x100dcc4e0&gt; 不同的对象 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'x': 1&#125; &#123;'x': 1&#125; b.y = 3 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'x': 1, 'y': 3&#125; &#123;'x': 1, 'y': 3&#125; # 改变一个对象的状态，另一个对象的状态也随之改变。def new_method(): b = Borg1() b1 = Borg1() print(b, b1) # &lt;__main__.Borg1 object at 0x109b33ac8&gt; &lt;__main__.Borg1 object at 0x109b33a90&gt; 不同的对象 b.y = 2 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'y': 2&#125; &#123;'y': 2&#125; # 改变一个对象的状态，另一个对象的状态也随之改变。 讲解： python使用__dict__存储一个类所有对象的状态。 dir()函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。一个实例的__dict__属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。 总之：dir()函数会自动寻找一个对象的所有属性，包括__dict__中的属性。__dict__是dir()的子集，dir()包含__dict__中的属性。 单例模式确保类有且只有一个特定类型的对象，并提供一个全局的访问点。控制共享资源的并行访问。 常用于： 日志记录，数据库操作，打印机后台处理操作等。这类程序的特点是，运行过程中只能生成一个实例，以避免对同一资源产生相互冲突的请求。 UML图： Singleton |———————-|-instance: Singleton |-Singleton() +instance(): Singleton| 实现单例模式的简单方法是：使构造函数私有化，并创建一个静态方法来完成对象的初始化。但python无法创建私有的构造函数，因此实现方法需要变通。 经典单例实现：12345class Singleton(object): def __new__(cls): if not hasattr(cls, 'instance'): # 创建对象之前，先检查对象是否存在 cls.instance = super(Singleton, cls).__new__(cls) return cls.instance ###讲解： __new__方法和__init__方法： __init__方法：创建实例后会立即执行对象的__init__方法。该方法接受一个位置参数self，然后可以接受任意数量的必要或可选的位置参数，以及任意数量的关键字参数。类调用的初始化参数会被传递给__init__方法。需要注意：__init__方法并没有创建新的对象，该方法目的在于为创建后的对象提供初始化的数据。因此它也不返回任何值，否则会导致TypeError错误。 12345678910&gt; class Dice(object):&gt; def __init__(self, sides=6):&gt; self._sides = sides&gt; def roll(self):&gt; return random.randint(1, self._sides)&gt; &gt; die = Dice() # random int in (1,6)&gt; die = Dice(sides=20)&gt; print(die.roll()) # random int in (1,20)&gt; __new__方法：实际在__init__方法之前执行，它才是负责创建并返回实例的方法。__new__方法永远是静态的，也无须显式装饰。第一重要参数是创建实例的类(习惯命名为cls)。大多数情况下，__new__方法其他参数会被完整的复制到__init__方法中。实际应用中，大多数类无须定义该方法，内置实现已经足够。但一个类需要定义该方法时，几乎都需要首先在实现本类逻辑之前引用负累的实现。需要注意：如果__new__方法返回的不是当前类的实例，就不会调用__init__方法。 123456&gt; class MyClass(object):&gt; def __new__(cls, [...]):&gt; instance = super(MyClass, cls).__new__(cls, [...])&gt; # do work on instance&gt; return instance&gt; hasattr()方法，用于判断对象是否包含对应的属性。hasattr(object, name) 123456&gt; class Coordinate:&gt; x = 10&gt; &gt; point1 = Coordinate() &gt; print(hasattr(point1, 'x')) # True&gt; print(hasattr(point1, 'y')) # False 懒汉式实例化确保在实际需要的时候才创建对象，节约资源。 1234567891011121314151617181920class Singleton: __instance = None def __init__(self): if not Singleton.__instance: print(\"__init__ method called..\") else: print(\"instance already created: \", Singleton.getInstance()) @classmethod def getInstance(cls): if not cls.__instance: cls.__instance = Singleton() return cls.__instanceif __name__ == '__main__': s = Singleton() # 初始化类调，调用init方法，但是新对象并没有创建。 print(\"object created:\", Singleton.getInstance()) # 实际的对象创建发生在调用Singleton.getInstance()的时候 s1 = Singleton() # 对象已经被创建。 模块级别的单例模式默认情况下，所有模块都是单例。由python的导入行为决定的。模块导入的时候，就会被初始化。当模块再次导入的时候，它不会再次初始化，它会返回同一个对象。 Monostate（单态）单例模式得到不同的对象，但对象的状态却是相同的。 123456789101112131415161718192021222324252627282930313233343536373839class Borg: __shared_state = &#123;\"x\": 1&#125; def __init__(self): self.y = 2 self.__dict__ = self.__shared_state passclass Borg1(object): __shared_state = &#123;&#125; def __new__(cls, *args, **kwargs): obj = super(Borg1, cls).__new__(cls) obj.__dict__ = cls.__shared_state return objdef init_method(): b = Borg() b1 = Borg() print(b, b1) # &lt;__main__.Borg object at 0x100dcc390&gt; &lt;__main__.Borg object at 0x100dcc4e0&gt; 不同的对象 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'x': 1&#125; &#123;'x': 1&#125; b.y = 3 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'x': 1, 'y': 3&#125; &#123;'x': 1, 'y': 3&#125; # 改变一个对象的状态，另一个对象的状态也随之改变。def new_method(): b = Borg1() b1 = Borg1() print(b, b1) # &lt;__main__.Borg1 object at 0x109b33ac8&gt; &lt;__main__.Borg1 object at 0x109b33a90&gt; 不同的对象 b.y = 2 print(\"object state: \", b.__dict__, b1.__dict__) # object state: &#123;'y': 2&#125; &#123;'y': 2&#125; # 改变一个对象的状态，另一个对象的状态也随之改变。 讲解： python使用__dict__存储一个类所有对象的状态。 dir()函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。一个实例的__dict__属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。 总之：dir()函数会自动寻找一个对象的所有属性，包括__dict__中的属性。__dict__是dir()的子集，dir()包含__dict__中的属性。","categories":[{"name":"Python","slug":"Python","permalink":"http://piaoyeyin.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://piaoyeyin.top/tags/Python/"},{"name":"DesignPattern","slug":"DesignPattern","permalink":"http://piaoyeyin.top/tags/DesignPattern/"}]},{"title":"数据库相关","slug":"sql","date":"2017-10-13T10:00:36.000Z","updated":"2017-10-13T10:40:34.000Z","comments":true,"path":"2017/10/13/sql/","link":"","permalink":"http://piaoyeyin.top/2017/10/13/sql/","excerpt":"","text":"SQLAlchemy SQLAlchemy ORM教程之一：Create SQLAlchemy ORM教程之二：Query mysql PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。","categories":[{"name":"SQL","slug":"SQL","permalink":"http://piaoyeyin.top/categories/SQL/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://piaoyeyin.top/tags/Mysql/"},{"name":"SQLAlchemy","slug":"SQLAlchemy","permalink":"http://piaoyeyin.top/tags/SQLAlchemy/"},{"name":"ORM","slug":"ORM","permalink":"http://piaoyeyin.top/tags/ORM/"}]},{"title":"vps和shadowsocks配置","slug":"vps-shadowsocks","date":"2017-09-26T09:50:28.000Z","updated":"2017-09-26T10:40:02.000Z","comments":true,"path":"2017/09/26/vps-shadowsocks/","link":"","permalink":"http://piaoyeyin.top/2017/09/26/vps-shadowsocks/","excerpt":"","text":"登录vps管理界面 stop服务，重装系统，我选择了centos 7 64位 系统重装好后，会给你一个root密码，如果忘记了可以重置。 ssh登录vps ssh username@ipaddress -p port ,输入初始的root密码。 更改密码passwd 接下来就是干正事了 cd yum -y update yum -y install gcc yum -y install openssl-devel yum -y install wget yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks vi /etc/shadowsocks.json # 创建配置文件，自行修改ip和端口，还有登录ss的密码。 { \"server\":\"xxx.xx.x.xx\", \"server_port\":7777, \"password\":\"xxxxxxx\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":false, \"workers\": 1 } #设置开机启动 vi /etc/rc.local ssserver -c /etc/shadowsocks.json -d start #启动服务 ssserver -c /etc/shadowsocks.json -d start #停止服务 ssserver -c /etc/shadowsocks.json -d stop #重启服务 ssserver -c /etc/shadowsocks.json -d restart 客户端配置见官网吧","categories":[{"name":"Setting","slug":"Setting","permalink":"http://piaoyeyin.top/categories/Setting/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://piaoyeyin.top/tags/Shadowsocks/"}]},{"title":"Shell 相关问题","slug":"mac-shell-record","date":"2017-09-26T04:03:53.000Z","updated":"2017-11-20T09:29:43.913Z","comments":true,"path":"2017/09/26/mac-shell-record/","link":"","permalink":"http://piaoyeyin.top/2017/09/26/mac-shell-record/","excerpt":"","text":"最近再整理自己mac上的配置时候，发现有点（很）乱，包括版本管理之类的。所以打算重新整理一下，各个常用工具的配置啊，balabala之类的。 shell首先从shell着手吧，由于使用了oh-my-zsh，所以基于zsh做配置。打开zsh终端： 12➜ echo $SHELL/bin/zsh bash，sh，zsh，那么你的用的可能就是Bourne Shell的一个变种。Bourne Shell(简称sh) Unix默认的Shell，是其他Shell的开发基础。在Bourne Shell下有三种配置文件： / ect/profile/ect/bashrc~/.bash_profile Linux里边是.bashrc 而MAC 是.bash_profile 。/ect/profile (一般不建议修改这个文件)，全局（公有）配置，不管是哪个用户，登陆是都会读取该文件。/etc/bashrc 一般在这个文件中添加系统级环境变量，全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。~/.bash_profile 一般在这个文件中添加用户级环境变量。每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。~/.zshrc 在.zshrc文件末尾增加.bash_profile的引用：source ~/.bash_profile pythonJava java怎么执行shell脚本 Java执行shell遇到的各种问题 尤其是问题3，脚本中有关联脚本时，注意运行环境是当前java类的运行目录，而不是shell脚本的。 脚本常用技巧1. bash set 命令Bash 脚本 set 命令教程常用方法： 123456# 写法一set -euxo pipefail# 写法二set -euxset -o pipefail 或者执行脚本时传入参数 1$ bash -euxo pipefail script.sh 2. 系统关机和重启系统关机和重启 12345halt [OPTIONS...]poweroff [OPTIONS...]reboot [OPTIONS...]shutdown [OPTIONS...] [TIME] [WALL...]init [OPTIONS...] &#123;COMMAND&#125; 推荐使用的关机命令：halt，poweroff，init 0，shutdown，shutdown +5 “warning system will be shutdown after 5m”推荐使用的重启命令：reboot，ini 6，shutdown -r","categories":[{"name":"Shell","slug":"Shell","permalink":"http://piaoyeyin.top/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://piaoyeyin.top/tags/Shell/"},{"name":"Mac","slug":"Mac","permalink":"http://piaoyeyin.top/tags/Mac/"}]},{"title":"基于监控视频的前景目标提取","slug":"BackgroundSubtraction","date":"2017-09-16T20:14:12.000Z","updated":"2017-09-17T17:35:23.000Z","comments":true,"path":"2017/09/17/BackgroundSubtraction/","link":"","permalink":"http://piaoyeyin.top/2017/09/17/BackgroundSubtraction/","excerpt":"","text":"题目基于监控的目标检测 准备工作4天时间，能完成多少是多少吧，然而准备工作是最烦的了，加上之前没有捣弄过，T T 安装opencv brew install cmakebrew install pkg-configbrew tap homebrew/sciencebrew install opencv这样就安装好了opencv3.3，不得不说homebrew简直神器！然后一些其他库brew install boost然而cmake的时候发生：Boost include path: /usr/local/include Could not find the following Boost libraries: boost_python黑线脸。。。明明都已经sudo chmod -R 777 /usr/local/includesudo chmod -R 777 /usr/local/libbrew link boost还居然报错，垃圾。怎么解决呢？看来方向错了，一查原来是没有安装boost-python。只好靠brew install boost-python弥补一下，其实在装boost的时候brew install boost --with-python 就好了。自己已经有的环境,python2.7.13, gcc 。重新cmake： 12345678910111213141516171819202122232425262728293031-- BGSLIBRARY WITH PYTHON SUPPORT: ON-- PYTHON VERSION: 2-- OpenCV library status:-- version: 3.3.0-- libraries: opencv_calib3d;opencv_core;opencv_dnn;opencv_features2d;opencv_flann;opencv_highgui;opencv_imgcodecs;opencv_imgproc;opencv_ml;opencv_objdetect;opencv_photo;opencv_shape;opencv_stitching;opencv_superres;opencv_video;opencv_videoio;opencv_videostab;opencv_aruco;opencv_bgsegm;opencv_bioinspired;opencv_ccalib;opencv_datasets;opencv_dpm;opencv_face;opencv_fuzzy;opencv_img_hash;opencv_line_descriptor;opencv_optflow;opencv_phase_unwrapping;opencv_plot;opencv_reg;opencv_rgbd;opencv_saliency;opencv_stereo;opencv_structured_light;opencv_surface_matching;opencv_text;opencv_tracking;opencv_xfeatures2d;opencv_ximgproc;opencv_xobjdetect;opencv_xphoto-- include path: /usr/local/include;/usr/local/include/opencv-- SEARCHING FOR BOOST COMPONENT FOR PYTHON 2CMake Warning at /usr/local/Cellar/cmake/3.9.2/share/cmake/Modules/FindBoost.cmake:767 (message): Imported targets not available for Boost version 106501Call Stack (most recent call first): /usr/local/Cellar/cmake/3.9.2/share/cmake/Modules/FindBoost.cmake:871 (_Boost_COMPONENT_DEPENDENCIES) /usr/local/Cellar/cmake/3.9.2/share/cmake/Modules/FindBoost.cmake:1501 (_Boost_MISSING_DEPENDENCIES) CMakeLists.txt:94 (find_package)-- Boost version: 1.65.1-- Found the following Boost libraries:-- python-- Boost library status:-- version: 106501-- libraries: /usr/local/lib/libboost_python-mt.dylib-- include path: /usr/local/include-- Python library status:-- executable: /usr/bin/python-- version: 2.7.10-- library: /usr/lib/libpython2.7.dylib-- include path: /usr/include/python2.7-- NUMPY_INCLUDE_DIR: /Users/zhouyu/Library/Python/2.7/lib/python/site-packages/numpy/core/include-- Configuring done-- Generating done-- Build files have been written to: /Users/zhouyu/Github/bgslibrary/build 成功，wonderful，准备工作告一段落。","categories":[{"name":"CV","slug":"CV","permalink":"http://piaoyeyin.top/categories/CV/"}],"tags":[{"name":"Opencv","slug":"Opencv","permalink":"http://piaoyeyin.top/tags/Opencv/"}]},{"title":"经济就是对稀缺资源的利用","slug":"resource-list","date":"2017-09-14T10:20:06.000Z","updated":"2017-09-16T20:13:19.000Z","comments":true,"path":"2017/09/14/resource-list/","link":"","permalink":"http://piaoyeyin.top/2017/09/14/resource-list/","excerpt":"","text":"NLP相关 国家语委现代汉语语料库 语料库介绍: 国家语委现代汉语语料库是一个大规模的平衡语料库,语料选材类别广泛,时间跨度大。在线提供检索的语料经过分词和词性标注,可以进行按词检索和分词类的检索。该语料库于1991年12月由国家语言文字工作委员会提出立项,1998年底建成,被列为国家语委“九五”“十五”科研重大项目,得到国家科技部“863”“973”计划多个项目支持(“智能中文信息处理平台”“图像、语音和自然语言理解”“中文信息处理应用基础研究”)。 国家语委现代汉语通用平衡语料库全库约为1亿字符,其中1997年以前的语料约7000万字符,均为手工录入印刷版语料;1997之后的语料约为3000万字符,手工录入和取自电子文本各半。标注语料库为国家语委现代汉语通用平衡语料库全库的子集,约5000万字符。标注是指分词和词类标注,已经经过3次人工校对,准确率大于&gt;98%。 国家语委现代汉语通用平衡语料库·标注语料库数据及使用说明语料库详细介绍 视觉相关 经典数据集在不同的模型下分类性能对比","categories":[{"name":"Resource","slug":"Resource","permalink":"http://piaoyeyin.top/categories/Resource/"}],"tags":[{"name":"Resource","slug":"Resource","permalink":"http://piaoyeyin.top/tags/Resource/"}]},{"title":"BiLSTM+CRF实现分词、命名实体识别、词性标注","slug":"BiLSTM-CRF-for-WordSegment","date":"2017-09-14T09:31:08.000Z","updated":"2017-09-25T05:04:11.000Z","comments":true,"path":"2017/09/14/BiLSTM-CRF-for-WordSegment/","link":"","permalink":"http://piaoyeyin.top/2017/09/14/BiLSTM-CRF-for-WordSegment/","excerpt":"","text":"Task 清楚英文的实现，使用tensorflow 扩展到中文分词 话不多说，先看papers： References[1]Bidirectional LSTM-CRF Models for Sequence Tagging. 2015Read Full PDF 摘要 基于序列标注提出的变种LSTM模型，这些模型包括LSTM，BI-LSTM（双向LSTM），LSTM结合CRF（条件随机场）层，bi-LSTM结合CRF层。","categories":[{"name":"NaturalLanguage","slug":"NaturalLanguage","permalink":"http://piaoyeyin.top/categories/NaturalLanguage/"}],"tags":[{"name":"NaturalLanguage","slug":"NaturalLanguage","permalink":"http://piaoyeyin.top/tags/NaturalLanguage/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://piaoyeyin.top/tags/DeepLearning/"},{"name":"LSTM","slug":"LSTM","permalink":"http://piaoyeyin.top/tags/LSTM/"}]},{"title":"tensorflow踩的坑","slug":"tensorflow","date":"2017-09-14T08:27:04.000Z","updated":"2017-09-25T05:03:52.000Z","comments":true,"path":"2017/09/14/tensorflow/","link":"","permalink":"http://piaoyeyin.top/2017/09/14/tensorflow/","excerpt":"","text":"install具体详见源码安装吧，cpu-only，一是自己小破本不支持gpu( If I hit five million in the lottery, I would buy a GTX1080ti to play a game first. :)，二是先跑起来再说吧。教程github源码run demo可能会出现一些warning，试试下面方法解决。 mkdir _python_buildcd _python_buildln -s ../bazel-bin/tensorflow/tools/pip_package/build_pip_package.runfiles/org_tensorflow/ .ln -s ../tensorflow/tools/pip_package/ .python setup.py develop 之后每次修改C++文件, 或者添加, 删除, 移动或修改任何Python文件之后, 都需要运行bazel build -c opt //tensorflow/tools/pip_package:build_pip_package重新构建（参数根据情况设置，参考教程吧）。 理解图计算先构建图，再执行图。 使用图 graph 来表示计算任务. 在被称之为 会话 session的上下文 (context) 中执行图. 使用 tensor 表示数据，看作是一个 n 维的数组或列表，包含Rank``Shape``Type 通过 变量 Variable维护状态信息. 使用feed 和fetch可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据. 交互式的使用为了便于使用诸如 IPython 之类的 Python 交互环境, 可以使用 InteractiveSession 代替 Session类, 使用 Tensor.eval() 和 Operation.run() 方法代替 Session.run() . 这样可以避免使用一个变量来持有会话. Feed feed 机制可以临时替代图中的任意操作中的tensor, 可以对图中任何操作提交补丁, 直接插入一个 tensor. feed 使用一个 tensor值临时替换一个操作的输出结果. 你可以提供 feed 数据作为 run() 调用的参数. feed只在调用它的方法内有效, 方法结束, feed就会消失. 最常见的用例是将某些特殊的操作指定为feed操作, 标记的方法是使用 tf.placeholder() 为这些操作创建占位符.","categories":[{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://piaoyeyin.top/categories/Tensorflow/"}],"tags":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://piaoyeyin.top/tags/MachineLearning/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://piaoyeyin.top/tags/Tensorflow/"}]},{"title":"Github开源的不只是code，而是n种思想","slug":"GithubMind","date":"2017-09-12T14:32:53.000Z","updated":"2017-09-14T09:49:15.000Z","comments":true,"path":"2017/09/12/GithubMind/","link":"","permalink":"http://piaoyeyin.top/2017/09/12/GithubMind/","excerpt":"","text":"介绍一些有趣有用的github projects &amp; minds 机器学习系列深度学习 《深度学习》— 中文版 https://github.com/exacity/deeplearningbook-chinese 《深度学习读书笔记》https://github.com/exacity/simplified-deeplearning 其他取其精华，弃其糟粕 提问的智慧 https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way 在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://piaoyeyin.top/categories/Knowledge/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://piaoyeyin.top/tags/Github/"}]},{"title":"朝花不可夕拾","slug":"WhateverYouKnow","date":"2017-09-12T11:28:21.000Z","updated":"2017-09-13T10:48:49.000Z","comments":true,"path":"2017/09/12/WhateverYouKnow/","link":"","permalink":"http://piaoyeyin.top/2017/09/12/WhateverYouKnow/","excerpt":"","text":"本文长期更新，用于记忆一些知识碎片，主要以简介和链接的形式展示。 Natural Language ModelsVariational Autoencoders keywords:自编码器、生成模型、非监督学习 AboutVAE is the state-of-the-art generative model, another is GAN. Related Papers Tutorial on Variational Autoencoders This tutorial introduces the intuitions behind VAEs, explains the mathematics behind them, and describes some empirical behavior. No prior knowledge of variational Bayesian methods is assumed. Related Blogs what is variational autoencoder Understanding Variational Autoencoders (VAEs) from two perspectives: deep learning and graphical models. VAE在NLP领域的应用 From PaperWeekly 《Generating Sentences From a Continuous Spaces》. ICLR 2016 《Neural Variational Inference for Text Processing》. ICML 2016 《Language as a Latent Variable: Discrete Generative Models for Sentence Compression》. EMNLP 2016 《A Hierarchical Latent Variable Encoder-Decoder Model for Generating Dialogues》. AAAI 2017 《Variational neural machine translation》. EMNLP 2016 《A Hybrid Convolutional Variational Autoencoder for Text Generation》 Applications of Autoencoders in Natural Language Processing Autoencoders for Representation and Deep Learning;Applications in Natural Language Processing; 来自知乎的 知乎里的理解 From Gerry CheVAE本质上不是一个deep generative model. 因为它实质上只是学习一个两层的graphical model. 知乎学术兴趣小组：VAEs Github Projects tensorflow/models/autoencoder 珠算：贝叶斯深度学习的GPU库 来自机器之心的简介 Extend SGVB (stochastic gradient variational bayes) 随机梯度变分贝叶斯 CVAE 条件变分自编码器 参数初始化方法Xavier InitializationAbout 它的特点是会根据某一层网络的输入输出节点数量自动调整最合适的分布。 Related PapersUnderstanding the difficulty of training deep feedforward neural networks.Xavier &amp; Yoshua 2010. Related Blogs 简书—自编码器参数初始化方法-Xavier initialization 知乎 — 深度前馈网络与Xavier初始化原理 Layer-sequential unit-variance (LSUV) initializationRelated PapersAll you need is a good init Recent methods All You Need is Beyond a Good Init: Exploring Better Solution for TrainingExtremely Deep Convolutional Neural Networks with Orthonormality andModulation ；可进一步参考其 Related Work。","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"http://piaoyeyin.top/categories/Knowledge/"}],"tags":[{"name":"NaturalLanguage","slug":"NaturalLanguage","permalink":"http://piaoyeyin.top/tags/NaturalLanguage/"},{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://piaoyeyin.top/tags/DeepLearning/"},{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://piaoyeyin.top/tags/MachineLearning/"}]},{"title":"java数据结构之map类","slug":"second","date":"2017-09-11T16:42:01.000Z","updated":"2017-09-12T12:38:27.000Z","comments":true,"path":"2017/09/12/second/","link":"","permalink":"http://piaoyeyin.top/2017/09/12/second/","excerpt":"","text":"java.util包中的map类HashMap","categories":[{"name":"Java","slug":"Java","permalink":"http://piaoyeyin.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://piaoyeyin.top/tags/Java/"},{"name":"DataStruct","slug":"DataStruct","permalink":"http://piaoyeyin.top/tags/DataStruct/"},{"name":"Map","slug":"Map","permalink":"http://piaoyeyin.top/tags/Map/"}]},{"title":"不要辜负属于你的时代","slug":"first","date":"2017-09-07T15:54:37.000Z","updated":"2017-09-11T06:54:03.000Z","comments":true,"path":"2017/09/07/first/","link":"","permalink":"http://piaoyeyin.top/2017/09/07/first/","excerpt":"","text":"给剩余的2017年的自己定几个业余的小目标吧： 把自己的小博客网站搭起来，随便乱写些东西 python写个小爬虫的项目吧 把英语学一学，没过的还是要过的，某某书什么的坚持看一看，不然喝酒的时候听不懂他们在说什么 java数据结构的东西过一遍吧 django玩一玩，感觉还是蛮有趣的 毕业论文还是要花心思准备，如果说搞隐私数据保护，那就得好好去实践一下，先别说创新吧，至少已有的stateoftheart方法在新的应用数据上有成效吧 找个女朋友不过分吧（开玩笑的，不存在的）–未完待续– 20170904","categories":[{"name":"Jotting","slug":"Jotting","permalink":"http://piaoyeyin.top/categories/Jotting/"}],"tags":[{"name":"Myself","slug":"Myself","permalink":"http://piaoyeyin.top/tags/Myself/"}]}]}